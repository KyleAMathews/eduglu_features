<?php

include_once('eduglue.features.inc');

/**
 * The default site mode of Eduglue - only authenticated users may
 * access content and registration is not allowed.
 */
define('ATRIUM_SITEMODE_PRIVATE', 0);

/**
 * Anonymous users may view public content and user registration is
 * open to the public.
 */
define('ATRIUM_SITEMODE_PUBLIC', 1);

/**
 * Anonymous users may view public content and user registration is
 * moderated.
 */
define('ATRIUM_SITEMODE_CONTROLLED', 2);

/**
 * Users may view all members of the site.
 */
define('ATRIUM_MEMBERS_ALL', 0);

/**
 * Users may only view members that belong to their groups.
 */
define('ATRIUM_MEMBERS_GROUP', 1);


/**
 * Implementation of hook_init().
 */
function eduglue_init() {
  // Alert the user that they are browsing an archived group.
  $space = spaces_get_space();
  if ($space && eduglue_is_archived($space)) {
    $message = t('This !type is <strong>archived</strong>. You may not add or alter any of its content.', array('!type' => eduglue_get_typename('group')));
    if (node_access('update', $space->group)) {
      $message .= ' '. t('To reactivate this !type, !link.', array('!type' => eduglue_get_typename('group'), '!link' => l(t('click here'), "node/$space->sid/reactivate")));
    }
    drupal_set_message($message);
  }
}

/**
 * Function that checks whether a group has been archived.
 */
function eduglue_is_archived($space = NULL) {
  switch ($space->type) {
    case 'og':
      return !$space->group->status;
  }
  return FALSE;
}

/**
 * Implementation of hook_views_api().
 */
function eduglue_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'eduglue') .'/includes',
  );
}

/**
 * Implemenation of hook_nodeapi().
 */
function eduglue_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  switch ($op) {
    case 'prepare':
    case 'view':
      // Confirm we are actually on a page of relevance
      if (menu_get_object() === $node) {
        // Set the context for the root book node type when on a book child page
        if (!empty($node->book['bid'])) {
          $type = db_result(db_query("SELECT type FROM {node} WHERE nid = %d", $node->book['bid']));
          context_set_by_condition('node', $type, TRUE);
        }
        // Display a message for archived content
        if ($op == 'view' && $node->status == 0) {
          $message = t('This !type is <strong>archived</strong>.', array('!type' => eduglue_get_typename($node->type)));
          if (node_access('update', $node)) {
            $message .= ' '. t('To reactivate this !type, !link.', array('!type' => eduglue_get_typename($node->type), '!link' => l(t('click here'), "node/{$node->nid}/reactivate")));
          }
          drupal_set_message($message);
        }
      }
      break;
  }
}

/**
 * Implementation of hook_context_links_alter();
 */
function eduglue_context_links_alter(&$links) {
  if (context_get('spaces', 'feature') == 'book' && isset($links['book']) && $space = spaces_get_space()) {
    if ($space->feature_access('book') && $node = menu_get_object()) {
      if (!empty($node->book['mlid'])) {
        $links['book']['query'] = 'parent='. $node->book['mlid'];
      }
    }
  }
}

/**
 * Implementation of hook_features_menu_links_alter().
 *
 * Make features menu skinnable
 */
function eduglue_features_menu_links_alter(&$links) {
  $links = eduglue_skin_links($links, TRUE);
}
/**
 * Implementation of hook_menu().
 */
function eduglue_menu() {
  $items = array();
  $items['help'] = array(
    'title' => 'Help',
    'description' => 'Information and help about using the site.',
    'page callback' => 'eduglue_help_page',
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'eduglue.pages.inc',
  );
  $items['node/%node/reactivate'] = array(
    'title' => 'Reactivate',
    'description' => 'Reactivate confirmation for unpublished nodes.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('eduglue_reactivate', 1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implementation of hook_perm().
 */
function eduglue_perm() {
  // Gives users access to all "easy administration" tools in Eduglue.
  return array('administer eduglue');
}

/**
 * Implementation of hook_menu_alter().
 */
function eduglue_menu_alter(&$callbacks) {
  // Replace taxonomy autocomplete with our own space-aware autocomplete
  if (module_exists('taxonomy')) {
    $callbacks['taxonomy/autocomplete']['page callback'] = 'eduglue_taxonomy_autocomplete';
    $callbacks['taxonomy/autocomplete']['module'] = 'eduglue';
    $callbacks['taxonomy/autocomplete']['file'] = 'eduglue.pages.inc';
  }

  // @TODO Replace user autocomplete with space-aware / "user access" aware autocomplete

  // Hijack the /node callback for use as our welcome page
  $callbacks['node']['page callback'] = 'drupal_goto';
  $callbacks['node']['page arguments'] = array('welcome');

  // Administration pages
  if (module_exists('admin')) {
    $callbacks = array_merge($callbacks, admin_menu_clone_items('admin/build/features', 'admin/features', $callbacks));
    $callbacks['admin/features']['options'] = array('admin' => TRUE);
    $callbacks['admin/features']['menu_name'] = 'admin';
  }
}

/**
 * Implementation of hook_block().
 */
function eduglue_block($op = 'list', $delta = 0) {
  switch ($op) {
    case 'list':
      return array(
          'info' => t('Eduglue: Book'),
          'spacelinks' => array('info' => t('Eduglue Intranet: Space links')),
          'create' => array('info' => t('Eduglue Intranet: Create content')),
          );
      return $blocks;
    case 'view':
      $function = "_eduglue_block_{$delta}";
      if (function_exists($function)) {
        return call_user_func($function);
      }
      break;
  }
}

/**
 * Implementation of hook_form_alter().
 */
function eduglue_form_alter(&$form, &$form_state, $form_id) {
  if ($form['#id'] == 'node-form') {
    $node = $form['#node'];

    // Book mods
    if ($form['#id'] == 'node-form' && book_type_is_allowed($form['#node']->type)) {
      $node = $form['#node'];

      if (!empty($form['book'])) {
        // Fieldset mods
        $form['book']['#weight'] = !empty($form['body_field']['#weight']) ? $form['body_field']['#weight'] : 0;
        $form['book']['#collapsible'] =
        $form['book']['#collapsed'] = FALSE;

        if (!empty($form['book']['bid']['#options'])) {
          // Remove "none" option -- do not allow book pages to be orphaned
          unset($form['book']['bid']['#options'][0]);
          // Filter book options by current space
          if ($view = views_get_view('eduglue_book_current')) {
            $view->set_display();
            $view->set_items_per_page(0);
            $view->execute();

            // Collect books in this space into an array
            $books = array();
            $books[$node->nid] = 1;
            if (is_array($view->result) && count($view->result)) {
              foreach($view->result as $row) {
                $books[$row->nid] = 1;
              }
            }

            // Use collected array to filter options
            foreach ($form['book']['bid']['#options'] as $k => $v) {
              if (is_numeric($k) && !isset($books[$k])) {
                unset($form['book']['bid']['#options'][$k]);
              }
            }
          }
        }
      }
    }

    $space = spaces_get_space();

    // Determine whether this node is archivable
    $archivable = in_array($node->type, variable_get('eduglue_archivable', array()));
    $archivable = !empty($node->nid) && $archivable;

    // Only allow root books to be archived.
    if (book_type_is_allowed($node->type)) {
      $archivable = $archivable && (!empty($node->book) && $node->book['plid'] == 0);
    }

    // Add a link to archive/reactive the space
    if ($archivable) {
      // Add archive / reactivate buttons
      if ($node->status) {
        $archive_help = t('This !type is currently <strong>active</strong>. You can archive it to hide it from listings and prevent others from adding to or altering its content. You can always undo this action by reactivating the !type.', array('!type' => eduglue_get_typename($node->type)));
      }
      else {
        $archive_help = t('This !type is currently <strong>archived</strong>. You can reactivate it to allow others to add and alter its content.', array('!type' => eduglue_get_typename($node->type)));
      }
      $form['archive'] = array(
        '#type' => 'fieldset',
        '#description' => $archive_help,
        '#weight' => 100,
      );
      $form['archive']['button'] = array(
        '#type' => 'submit',
        '#value' => $node->status ? t('Archive this !type', array('!type' => eduglue_get_typename($node->type))) : t('Reactivate'),
        '#submit' => $node->status ? array('eduglue_archive_submit') : array('eduglue_reactivate_submit'),
      );
    }
    // Disable other node forms in archived spaces
    else if (eduglue_is_archived($space)) {
      drupal_access_denied(); exit;
    }
  }
}

/**
 * Implementation of hook_form_alter for system_themes_form.
 * Limit options to themes that implement eduglue compatibility.
 */
function eduglue_form_system_themes_form_alter(&$form, $form_state) {
  $themes = system_theme_data();
  foreach ($themes as $key => $theme) {
    if (empty($theme->info['eduglue'])) {
      unset($form[$key]);
      unset($form['status']['#options'][$key]);
      unset($form['theme_default']['#options'][$key]);
    }
  }
}

/**
 *  Implementation of hook_form_alter for node_type_form.
 */
function eduglue_form_node_type_form_alter(&$form, $form_state) {
  if (isset($form['identity']['type'])) {
    $form['eduglue'] = array(
      '#type' => 'fieldset',
      '#title' => t('Eduglue'),
      '#tree' => FALSE,
      '#collapsible' => FALSE,
      '#collapsed' => FALSE,
    );
    $form['eduglue']['eduglue_update_type'] = array(
      '#type' => 'checkbox',
      '#title' => t('Show in recent activity views'),
      '#description' => t('Show this content type in activity streams, update lists, etc.'),
      '#default_value' => variable_get('eduglue_update_type_'. $form['#node_type']->type, TRUE),
    );
  }
}

/**
 * Form alter for views exposed forms.
 */
function eduglue_form_views_exposed_form_alter(&$form, $form_state) {
  // Quick check that this is the right view
  $view = views_get_current_view();
  if ($view && $view->name === 'eduglue_search' && !empty($form['created'])) {
    $options = array(
      '-14 days' => t('2 weeks ago'),
      '-30 days' => t('1 month ago'),
      '-180 days' => t('6 month ago'),
      '' => t('Anytime'),
    );
    $form['created']['#type'] = 'select';
    $form['created']['#options'] = $options;
    unset($form['created']['#size']);
  }
}

/**
 * OG archive submit handler.
 */
function eduglue_archive_submit($form, &$form_state) {
  $nid = $form_state['values']['nid'];
  $node = node_load($nid);
  $node->status = 0;
  node_save($node);
  drupal_set_message(t('The @type @title has been archived.', array('@type' => eduglue_get_typename($node->type), '@title' => $node->title)));
  $form_state['redirect'] = "node/{$node->nid}";
}

/**
 * Reactivate node submit handler.
 */
function eduglue_reactivate_submit($form, &$form_state) {
  $nid = $form_state['values']['nid'];
  $node = node_load($nid);
  $node->status = 1;
  node_save($node);
  drupal_set_message(t('The @type @title has been reactivated.', array('@type' => eduglue_get_typename($node->type), '@title' => $node->title)));
  $form_state['redirect'] = "node/{$node->nid}";
}

/**
 * Menu callback for reactivation confirmation form.
 */
function eduglue_reactivate($form_state, $node) {
  $form = array();
  $form['nid'] = array('#type' => 'value', '#value' => $node->nid);
  $form['#submit'] = array('eduglue_reactivate_submit');
  return confirm_form($form, t('Are you sure you want to reactivate %title?', array('%title' => $node->title)), "node/{$node->nid}", '', t('Reactivate'), t('Cancel'));
}

/**
 * Abstracts the node types provided in update streams/feed views.
 */
function eduglue_update_types($reset = FALSE) {
  static $types;
  if (!isset($types) || $reset) {
    $types = array();
    foreach (array_keys(node_get_types()) as $type) {
      if (variable_get('eduglue_update_type_'. $type, TRUE)) {
        $types[] = $type;
      }
    }
  }
  return $types;
}

/**
 * Small API function to make retrieving the human-readable node type
 * name easier.
 */
function eduglue_get_typename($type, $lower = TRUE) {
  $types = node_get_types();
  if (!empty($types[$type])) {
    return $lower ? strtolower($types[$type]->name) : $types[$type]->name;
  }
  return FALSE;
}

/**
 * Wrapper access callback to provide access check against both a spaces
 * feature and an access perm.
 */
function eduglue_feature_access($feature, $perm = 'access content') {
  return spaces_feature_access($feature) && user_access($perm);
}

/**
 * BLOCKS =============================================================
 */

/**
 * Feature-aware book block.
 */
function _eduglue_block_book() {
  context_set('eduglue', 'book', 'rendering');

  $space = spaces_get_space();
  $block = array();
  if ($space) {
    if ($node = menu_get_object()) {
      $current_bid = empty($node->book['bid']) ? 0 : $node->book['bid'];
    }
    // Set customized title
    $features = spaces_features();
    $block['subject'] = t('Documents');

    // Generate book tree per book node in current space
    $output = '';
    if ($view = views_get_view('eduglue_book_current')) {
      $view->set_display();
      $view->set_items_per_page(0);
      $view->execute();
      if (is_array($view->result) && count($view->result)) {
        foreach($view->result as $row) {
          $output .= menu_tree(book_menu_name($row->nid));
        }
      }
    }
    $block['content'] = $output;
  }

  context_set('eduglue', 'book', FALSE);

  return $block;
}
function _eduglue_block_spacelinks() {
  $links = spaces_admin_links();
  if (!empty($links)) {
    return array('subject' => "<span class='icon'></span> ". t('Settings'), 'content' => theme('links', $links));
  }
}
function _eduglue_block_create() {  
  $space = spaces_get_space();
  $feature_map = spaces_features_map('node');
  $item = menu_get_item('node/add');
  dd("======new page load=====");
  dd($space);
  dd($feature_map);
  dd($item);
  if ($space) {
    $links = array();
    foreach (system_admin_menu_block($item) as $menu_item) {
      //dd($menu_item);
      $args = explode('/', $menu_item['href']);
      $type = str_replace('-', '_', array_pop($args));
      dd("==========type:");
      dd($type);
      if (isset($feature_map[$type]) && $space->feature_access($feature_map[$type]) && _eduglue_intranet_node_access_create($type)) {
        $feature = $feature_map[$type];
        $menu_item['title'] = "<span class='spaces-feature feature-{$feature}'></span>{$menu_item['title']}";
        $menu_item['html'] = TRUE;
        $links["$feature-{$type}"] = $menu_item;
      }
    }
    ksort($links);
    return array('subject' => "<span class='icon'></span> {$item['title']}", 'content' => theme('links', $links));
  }
  
}

/**
 * Helper callback that does a node_access('create') check without providing
 * any user_access() loopholes.
 */
function _eduglue_intranet_node_access_create($node) {
  global $user;
  $account = $user;

  // Can't use node_invoke(), because the access hook takes the $op parameter
  // before the $node parameter.
  $module = node_get_types('module', $node);
  if ($module == 'node') {
    $module = 'node_content'; // Avoid function name collisions.
  }
  $access = module_invoke($module, 'access', 'create', $node, $account);
  return !is_null($access) ? $access : FALSE;
}

/**
 * Helper function to ensure a permission exists in a roles array for a given role/perm.
 */
function _eduglue_ensure_perm(&$roles, $role, $perm) {
  if (!isset($roles[$role]['perm']) || !in_array($perm, $roles[$role]['perm'])) {
    $roles[$role]['perm'][] = $perm;
  }
}

/**
 * Helper function to remove a permission from a roles array for a given role/perm.
 */
function _eduglue_remove_perm(&$roles, $role, $perm) {
  if (in_array($perm, $roles[$role]['perm'])) {
    $position = array_search($perm, $roles[$role]['perm']);
    unset($roles[$role]['perm'][$position]);
  }
}

/**
 * THEME & UI  FUNCTIONS ==============================================
 */

/**
 * Implementation of hook_theme_registry_alter().
 */
function eduglue_theme_registry_alter(&$theme_registry) {
  if (!in_array('eduglue_preprocess_page', $theme_registry['page']['preprocess functions'])) {
    $theme_registry['page']['preprocess functions'][] = 'eduglue_preprocess_page';
  }
  // Yank out og_preprocess_node.
  if ($key = array_search('og_preprocess_node', $theme_registry['node']['preprocess functions'])) {
    unset($theme_registry['node']['preprocess functions'][$key]);
  }
}

/**
 * Implementation of preprocess_views_view().
 */
function eduglue_preprocess_views_view(&$vars) {
  if ($feature = context_get('spaces', 'feature')) {
    $contexts = context_enabled_contexts();
    $context = isset($contexts["spaces-feature-{$feature}"]) ? $contexts["spaces-feature-{$feature}"] : NULL;
    $view = $vars['view'];
    $space = spaces_get_space();

    if ($space && $context && strpos($view->current_display, 'page') !== FALSE && empty($view->result) && empty($vars['empty'])) {
      // @TODO determine why this can get called more than once for the
      // relevant view.
      static $once;
      if (!$once) {
        $once = TRUE;

        $output = '';
        global $user;

        // Get the first nodetype
        if (!empty($context->node)) {
          reset($context->node);
          $nodetype = current($context->node);
        }

        // Assemble a reasonable empty message
        if (!empty($nodetype) && node_access('create', $nodetype) && ($space->type == 'og')) {
          $types = node_get_types();
          if ($type = $types[$nodetype]) {
            $output .= t('Please add your first !type to get started.', array('!type' => $type->name));
            $output .= "<div class='buttons'>". theme('context_links', context_links()) ."</div>";
          }
        }
        else {
          $output .= t('There is currently no content to view in this section.');
        }
        $vars['empty'] = $output;
      }
    }
  }
}

/**
 * Add an "eduglue-skin" class to a links array for skinners.
 */
function eduglue_skin_links($links, $both = FALSE) {
  $new_links = array();
  foreach ($links as $k => $v) {
    if (!isset($v['attributes']['class'])) {
      $v['attributes']['class'] = 'eduglue-skin';
    }
    else {
      $v['attributes']['class'] .= ' eduglue-skin';
    }
    if ($both) {
      $new_links["$k eduglue-skin"] = $v;
    }
    else {
      $new_links[$k] = $v;
    }
  }
  return $new_links;
}